学习笔记

# 中间件和缓存类别

## 中间件

用户数据量增加导致服务、存储无法满足业务需求，需要对服务、存储进行横向的扩展

对于存储的横向扩展， 如MySQl通常用进行读写分离或表的拆分等

对于服务和应用则将单节点拆分成多节点，来满足业务的需求，此时由于多节点间需要共享数据

如登陆会话session，此时就需要使用一个中间的共享介质来存储多节点的会话。

这就是中间件产生的最初原因

### 中间件类型（实现形式）

#### 缓存

> 存储静态资源、存储热点数据

- 分类

    - 本地缓存
    - 分布式缓存

- 差异

    > 调用方式、开销

    - 本地缓存： 直接访问本地内存数据，效率高，但不支持分布式，存储数据与本地设备内存大小成正比
    - 分布式缓存： 通过网络远程调用，有一定的网络开销，但可以根据不同算法将数据分布到多个设备上，存储的数据更多

- 各自存储数据的特点

    - 本地缓存：一般缓存的是静态数据、配置数据
    - 分布式缓存：缓存全局数据，以及多个业务、多个模块间的共享的数据

- 各自适合的场景

- 缓存和数据库间的同步方式

    从应用角度：

    - Cache Aside 适合轻量级应用

        同步方式为：读缓存时，缓存中有目标数据就直接返回，没有就从数据库获取写入缓存并返回

        更新数据时，应用收到更新操作后会直接更新数据库，然后重写或更新缓存，最后返回用户更新完成

        优点： 实现简单、业务逻辑清晰

        缺点：更新缓存时，会对业务代码有侵入，需要了解后端的缓存架构，需要自已维护缓存的更新策略

    - Read Write Through  适用于频繁使用缓存进行读、写、更新操作的应用

        对于后台服务来看，缓存和数据库为一个整体，中间设有网关层提供的标准的Sql接口

        优点：后台不需考虑缓存和数据库，无需维护更新策略，直接读写网关层

        缺点：网关层需要维护缓存和数据库的更新逻辑

    - Write Back 适合于对数据一致性要求不高的场景

        ​		后台应用只关心缓存，对缓存进行读、写、更新，缓存与数据库间使用消息队列，缓存通过消息队列对数据库进行数据同步

        优点：不考虑数据持久化，读、写、更新效率高

        缺点：缓存到数据库使用异步读写，存在数据库丢失的风险

    从数据库角度：

    - 双写方式

        应用使用多线程方式将数据同时写入到缓存和数据库， 一般以数据库为标准，

        一种情况是写缓存成功，写数据库失败，采用分布式事物机制，数据库写入失败则全部回退

        一种情况是写数据成功，写缓存失败，则需要缓存定期同步数据库，或者增加监控

        优点：实现简单，效率高

        缺点：当某个线程出现异常导致写入失败时，存在数据不一致的风险，同是对业务逻辑有侵入，

        耦合度： 高

    - 消息队列方式 

        当并发请求较大，数据库无法满足时，在缓存和数据库间增加消息队列，数据写入缓存后，由缓存或应用调用消息队列，由消息队更将数据写入数据库

        变体：将消息队列进行持久化，缓存或应用将数据写入消息队列即认为数据持久化成功，从而进一步降低数据不致的风险

        优点：降低了数据不一致的风险

        缺点：效率比双写低

        耦合度： 中

    - MySQL的Binlog 方式

        应用该数据直接写入数据库，缓存通过Binlog进行回放获取数据

        优点：稳性高

        缺点： Binlog 是线性处理的，一旦堵住所有的请求都将发生阻塞， 性能最差

        耦合度： 低

    总结：

    1. 上述几种缓存同步方式，均存在一定的数据不致的风险，需要通过应用程序进行缓存和数据库的校对
    2. 为了保证数据的一致性，一般都是以数据库为准 
    3. 选用哪种同步方式，需要根据业务类形、场景、复杂度进行合理的选择

- 缓存可能出现的问题

    - 缓存穿透

        利用当前缓存中没有的数据，饶过缓存直接请求数据库，此时该请求的压力会落到数据库上，当存在大量这种请求时，会造成数据库压力暴增，产生分布式的拒绝服务攻击

        解决办法：

        1. 应用程序和数据库进行约定，如果发现取的数据是没有办法返回或者返回为空值，对空值进行缓存，缓存为null, 当再次请求该值时，由缓存返回已缓存的值

            建议：对数据没有办法返回或者返回为空值进行缓存时，应设置一个较短的缓存时间，因为如果大量存在这种值时会大量占用缓存空间，缓存时间过长的话，则会导致缓存空间被占满

        2. 使用布隆过滤器（存在现误杀现象）

            通过布隆过滤器设置过虑规则，判断数据是否在过滤规则的集合中，尽可能的把所有可能的值都缓存到过滤器中，当请求时，如果包含则返回过滤器中缓存的值，没有包含则返回NULL

    - 缓存并发（缓存击穿）

        当某一个KEY在某个时间点过期时，恰好在这个时间点有大量的并发请求这个KEY, 此时这些并发会直接请求到数据库上，造成服务器压力增大。当大量key同时过期并同时被大量并发请时，可能会产生拒绝服务攻击

        缓存并发与缓存穿透的区别：

        1. key：缓存并发的key是正常存在于缓存中，缓存穿透的key是不存在无缓存或数据库中的
        2. 请求: 缓存并发是正常的访问请求，缓存穿透可能是恶意的攻击请求 

        解决办法：

        1. 使用互斥锁。当缓存失效时，并发请求不立即发往数据库，当一个线程进行请求时，会先设置一个锁（Redis为SETNX) 再去请求数据库，然后将请求到的值缓存互缓存中，当有另一个线程请求同样的数据时，会先检查是否有锁，如果没有获得锁会进行阻塞，当上一线程请求结束并将数据存入缓存，该线程则会再次请求到缓存上，获取新缓存的数据

    - 缓存雪崩

        当缓存设置不合理或在同一时间同时缓存了大量相同过期时间的key时，这些key可能会在同一时间过期，可能同时发生大量的缓存并发，从而绕过缓存直接访问数据库，造成服务器压力增大。当大量key同时过期并同时被大量并发请时，即发生了缓存雪崩

        解决办法：

        1. 在缓存过期时上增加随机事件，防止大量的KEY同一时间失效
        2. 使用多级缓存的方式，使每一级的过期时间各不相同

    总结：

    三种问题产生的原因都是出了大量并发的请求直接打到数据库上，造成数据库的压力增大，需要根据实际的业务场景和特点提前进行优化和规避



#### 消息队列（订阅-发布）

> 将不同业务场景、不同业务，安全、正确的进行解耦



### 企业级应用为什么需要缓存和消息队列

- 随着业务规模扩大，单体应用不再满足业务场景需求
- 用户数量剧增，单凭数据库无法扛住并发压力
- 业务场景复杂需要解耦
- 业务场景丰富造成访问热点

